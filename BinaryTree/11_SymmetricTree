// Symmetric Tree in Iterative Method

bool isSymmetric(TreeNode* root) {
        if(root==NULL) return true;
        queue<TreeNode*> q;
        q.push(root), q.push(root);
        TreeNode *l=NULL, *r = NULL;
        
        while(!q.empty()) {
            l = q.front(); q.pop();
            r = q.front(); q.pop();
            
            if(l->val != r->val) return false;
            
            if(l->left && r->right) {
                q.push(l->left);
                q.push(r->right);
            }
            else if(l->left || r->right) return false;
            
            if(l->right && r->left) {
                q.push(l->right);
                q.push(r->left);
            }
            else if(l->right || r->left) return false;
        }
        return true;
    }
    
    Time Complexity: O(N)
    Space Complexity: O(N)
    
    
    // Symmetric Tree Recursive Method
   
    bool isMirror(TreeNode* root1,TreeNode* root2) {
        if(root1==NULL || root2==NULL) return root1 == root2;
        return (root1->val==root2->val) && isMirror(root1->left,root2->right) && isMirror(root1->right,root2->left);
    }
    bool isSymmetric(TreeNode* root) {
        if(root==NULL) return true;
        return isMirror(root->left,root->right);
    }
    
    Time Complexity: O(N)
    Space Complexity: O(N)
